"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-hyperscript";
exports.ids = ["vendor-chunks/slate-hyperscript"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-hyperscript/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/slate-hyperscript/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   createHyperscript: () => (/* binding */ createHyperscript),\n/* harmony export */   createText: () => (/* binding */ createText),\n/* harmony export */   jsx: () => (/* binding */ jsx)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n\n\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * A weak map to hold anchor tokens.\n */\nvar ANCHOR = new WeakMap();\n/**\n * A weak map to hold focus tokens.\n */\nvar FOCUS = new WeakMap();\n/**\n * All tokens inherit from a single constructor for `instanceof` checking.\n */\nclass Token {}\n/**\n * Anchor tokens represent the selection's anchor point.\n */\nclass AnchorToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"path\", void 0);\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n/**\n * Focus tokens represent the selection's focus point.\n */\nclass FocusToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"path\", void 0);\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n/**\n * Add an anchor token to the end of a text node.\n */\nvar addAnchorToken = (text, token) => {\n  var offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n/**\n * Get the offset if a text node has an associated anchor token.\n */\nvar getAnchorOffset = text => {\n  return ANCHOR.get(text);\n};\n/**\n * Add a focus token to the end of a text node.\n */\nvar addFocusToken = (text, token) => {\n  var offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n/**\n * Get the offset if a text node has an associated focus token.\n */\nvar getFocusOffset = text => {\n  return FOCUS.get(text);\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\nvar STRINGS = new WeakSet();\nvar resolveDescendants = children => {\n  var nodes = [];\n  var addChild = child => {\n    if (child == null) {\n      return;\n    }\n    var prev = nodes[nodes.length - 1];\n    if (typeof child === 'string') {\n      var text = {\n        text: child\n      };\n      STRINGS.add(text);\n      child = text;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(child)) {\n      var c = child; // HACK: fix typescript complaining\n      if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && slate__WEBPACK_IMPORTED_MODULE_1__.Text.equals(prev, c, {\n        loose: true\n      })) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      var n = nodes[nodes.length - 1];\n      if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(n)) {\n        addChild('');\n        n = nodes[nodes.length - 1];\n      }\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n    }\n  };\n  for (var child of children.flat(Infinity)) {\n    addChild(child);\n  }\n  return nodes;\n};\n/**\n * Create an anchor token.\n */\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\n/**\n * Create an anchor and a focus token.\n */\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\n/**\n * Create an `Element` object.\n */\nfunction createElement(tagName, attributes, children) {\n  return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\n/**\n * Create a focus token.\n */\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\n/**\n * Create a fragment.\n */\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\n/**\n * Create a `Selection` object.\n */\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find(c => c instanceof AnchorToken);\n  var focus = children.find(c => c instanceof FocusToken);\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  return _objectSpread$1({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\n/**\n * Create a `Text` object.\n */\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n  var [node] = nodes;\n  if (node == null) {\n    node = {\n      text: ''\n    };\n  }\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  }\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\n/**\n * Create a top-level `Editor` object.\n */\nvar createEditor = makeEditor => (tagName, attributes, children) => {\n  var otherChildren = [];\n  var selectionChild;\n  for (var child of children) {\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(child)) {\n      selectionChild = child;\n    } else {\n      otherChildren.push(child);\n    }\n  }\n  var descendants = resolveDescendants(otherChildren);\n  var selection = {};\n  var editor = makeEditor();\n  Object.assign(editor, attributes);\n  editor.children = descendants;\n  // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n  for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__.Node.texts(editor)) {\n    var anchor = getAnchorOffset(node);\n    var focus = getFocusOffset(node);\n    if (anchor != null) {\n      var [offset] = anchor;\n      selection.anchor = {\n        path,\n        offset\n      };\n    }\n    if (focus != null) {\n      var [_offset] = focus;\n      selection.focus = {\n        path,\n        offset: _offset\n      };\n    }\n  }\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (selectionChild != null) {\n    editor.selection = selectionChild;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(selection)) {\n    editor.selection = selection;\n  }\n  return editor;\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * The default creators for Slate objects.\n */\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(slate__WEBPACK_IMPORTED_MODULE_1__.createEditor),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\n/**\n * Create a Slate hyperscript function with `options`.\n */\nvar createHyperscript = function createHyperscript() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var {\n    elements = {}\n  } = options;\n  var elementCreators = normalizeElements(elements);\n  var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n  var jsx = createFactory(creators);\n  return jsx;\n};\n/**\n * Create a Slate hyperscript function with `options`.\n */\nvar createFactory = creators => {\n  var jsx = function jsx(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n    var creator = creators[tagName];\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n    if (attributes == null) {\n      attributes = {};\n    }\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n    children = children.filter(child => Boolean(child)).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n  return jsx;\n};\n/**\n * Normalize a dictionary of element shorthands into creator functions.\n */\nvar normalizeElements = elements => {\n  var creators = {};\n  var _loop = function _loop() {\n    var props = elements[tagName];\n    if (typeof props !== 'object') {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n    }\n    creators[tagName] = (tagName, attributes, children) => {\n      return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);\n    };\n  };\n  for (var tagName in elements) {\n    _loop();\n  }\n  return creators;\n};\n\n/**\n * The default hyperscript factory that ships with Slate, without custom tags.\n */\nvar jsx = createHyperscript();\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtaHlwZXJzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDbUM7O0FBRW5GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQUk7QUFDWixxQkFBcUI7QUFDckIsVUFBVSx1Q0FBSSx3REFBd0QsdUNBQUk7QUFDMUU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0sU0FBUywwQ0FBTztBQUN0QjtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcsdUNBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUNBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFLO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUNBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsd0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUU0RDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRlbmFpLy4vbm9kZV9tb2R1bGVzL3NsYXRlLWh5cGVyc2NyaXB0L2Rpc3QvaW5kZXguZXMuanM/OGQzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IFRleHQsIFJhbmdlLCBOb2RlLCBFbGVtZW50LCBjcmVhdGVFZGl0b3IgYXMgY3JlYXRlRWRpdG9yJDEgfSBmcm9tICdzbGF0ZSc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEEgd2VhayBtYXAgdG8gaG9sZCBhbmNob3IgdG9rZW5zLlxuICovXG52YXIgQU5DSE9SID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSB3ZWFrIG1hcCB0byBob2xkIGZvY3VzIHRva2Vucy5cbiAqL1xudmFyIEZPQ1VTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQWxsIHRva2VucyBpbmhlcml0IGZyb20gYSBzaW5nbGUgY29uc3RydWN0b3IgZm9yIGBpbnN0YW5jZW9mYCBjaGVja2luZy5cbiAqL1xuY2xhc3MgVG9rZW4ge31cbi8qKlxuICogQW5jaG9yIHRva2VucyByZXByZXNlbnQgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBwb2ludC5cbiAqL1xuY2xhc3MgQW5jaG9yVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvZmZzZXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXRoXCIsIHZvaWQgMCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuLyoqXG4gKiBGb2N1cyB0b2tlbnMgcmVwcmVzZW50IHRoZSBzZWxlY3Rpb24ncyBmb2N1cyBwb2ludC5cbiAqL1xuY2xhc3MgRm9jdXNUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9mZnNldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdGhcIiwgdm9pZCAwKTtcbiAgICB2YXIge1xuICAgICAgb2Zmc2V0LFxuICAgICAgcGF0aFxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG59XG4vKipcbiAqIEFkZCBhbiBhbmNob3IgdG9rZW4gdG8gdGhlIGVuZCBvZiBhIHRleHQgbm9kZS5cbiAqL1xudmFyIGFkZEFuY2hvclRva2VuID0gKHRleHQsIHRva2VuKSA9PiB7XG4gIHZhciBvZmZzZXQgPSB0ZXh0LnRleHQubGVuZ3RoO1xuICBBTkNIT1Iuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIG9mZnNldCBpZiBhIHRleHQgbm9kZSBoYXMgYW4gYXNzb2NpYXRlZCBhbmNob3IgdG9rZW4uXG4gKi9cbnZhciBnZXRBbmNob3JPZmZzZXQgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIEFOQ0hPUi5nZXQodGV4dCk7XG59O1xuLyoqXG4gKiBBZGQgYSBmb2N1cyB0b2tlbiB0byB0aGUgZW5kIG9mIGEgdGV4dCBub2RlLlxuICovXG52YXIgYWRkRm9jdXNUb2tlbiA9ICh0ZXh0LCB0b2tlbikgPT4ge1xuICB2YXIgb2Zmc2V0ID0gdGV4dC50ZXh0Lmxlbmd0aDtcbiAgRk9DVVMuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIG9mZnNldCBpZiBhIHRleHQgbm9kZSBoYXMgYW4gYXNzb2NpYXRlZCBmb2N1cyB0b2tlbi5cbiAqL1xudmFyIGdldEZvY3VzT2Zmc2V0ID0gdGV4dCA9PiB7XG4gIHJldHVybiBGT0NVUy5nZXQodGV4dCk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBSZXNvbHZlIHRoZSBkZXNjZWRhbnRzIG9mIGEgbm9kZSBieSBub3JtYWxpemluZyB0aGUgY2hpbGRyZW4gdGhhdCBjYW4gYmVcbiAqIHBhc3NlZCBpbnRvIGEgaHlwZXJzY3JpcHQgY3JlYXRvciBmdW5jdGlvbi5cbiAqL1xudmFyIFNUUklOR1MgPSBuZXcgV2Vha1NldCgpO1xudmFyIHJlc29sdmVEZXNjZW5kYW50cyA9IGNoaWxkcmVuID0+IHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBhZGRDaGlsZCA9IGNoaWxkID0+IHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdGV4dCA9IHtcbiAgICAgICAgdGV4dDogY2hpbGRcbiAgICAgIH07XG4gICAgICBTVFJJTkdTLmFkZCh0ZXh0KTtcbiAgICAgIGNoaWxkID0gdGV4dDtcbiAgICB9XG4gICAgaWYgKFRleHQuaXNUZXh0KGNoaWxkKSkge1xuICAgICAgdmFyIGMgPSBjaGlsZDsgLy8gSEFDSzogZml4IHR5cGVzY3JpcHQgY29tcGxhaW5pbmdcbiAgICAgIGlmIChUZXh0LmlzVGV4dChwcmV2KSAmJiBTVFJJTkdTLmhhcyhwcmV2KSAmJiBTVFJJTkdTLmhhcyhjKSAmJiBUZXh0LmVxdWFscyhwcmV2LCBjLCB7XG4gICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICBwcmV2LnRleHQgKz0gYy50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChuKSkge1xuICAgICAgICBhZGRDaGlsZCgnJyk7XG4gICAgICAgIG4gPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEFuY2hvclRva2VuKSB7XG4gICAgICAgIGFkZEFuY2hvclRva2VuKG4sIGNoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBGb2N1c1Rva2VuKSB7XG4gICAgICAgIGFkZEZvY3VzVG9rZW4obiwgY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGh5cGVyc2NyaXB0IGNoaWxkIG9iamVjdDogXCIuY29uY2F0KGNoaWxkKSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbi5mbGF0KEluZmluaXR5KSkge1xuICAgIGFkZENoaWxkKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW4gYW5jaG9yIHRva2VuLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBbmNob3IodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG5ldyBBbmNob3JUb2tlbihhdHRyaWJ1dGVzKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFuY2hvciBhbmQgYSBmb2N1cyB0b2tlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBbbmV3IEFuY2hvclRva2VuKGF0dHJpYnV0ZXMpLCBuZXcgRm9jdXNUb2tlbihhdHRyaWJ1dGVzKV07XG59XG4vKipcbiAqIENyZWF0ZSBhbiBgRWxlbWVudGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBhdHRyaWJ1dGVzKSwge30sIHtcbiAgICBjaGlsZHJlbjogcmVzb2x2ZURlc2NlbmRhbnRzKGNoaWxkcmVuKVxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZm9jdXMgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvY3VzKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgRm9jdXNUb2tlbihhdHRyaWJ1dGVzKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiByZXNvbHZlRGVzY2VuZGFudHMoY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICB2YXIgYW5jaG9yID0gY2hpbGRyZW4uZmluZChjID0+IGMgaW5zdGFuY2VvZiBBbmNob3JUb2tlbik7XG4gIHZhciBmb2N1cyA9IGNoaWxkcmVuLmZpbmQoYyA9PiBjIGluc3RhbmNlb2YgRm9jdXNUb2tlbik7XG4gIGlmICghYW5jaG9yIHx8IGFuY2hvci5vZmZzZXQgPT0gbnVsbCB8fCBhbmNob3IucGF0aCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxzZWxlY3Rpb24+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IGhhdmUgYW4gPGFuY2hvcj4gdGFnIGFzIGEgY2hpbGQgd2l0aCBgcGF0aGAgYW5kIGBvZmZzZXRgIGF0dHJpYnV0ZXMgZGVmaW5lZC5cIik7XG4gIH1cbiAgaWYgKCFmb2N1cyB8fCBmb2N1cy5vZmZzZXQgPT0gbnVsbCB8fCBmb2N1cy5wYXRoID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgPHNlbGVjdGlvbj4gaHlwZXJzY3JpcHQgdGFnIG11c3QgaGF2ZSBhIDxmb2N1cz4gdGFnIGFzIGEgY2hpbGQgd2l0aCBgcGF0aGAgYW5kIGBvZmZzZXRgIGF0dHJpYnV0ZXMgZGVmaW5lZC5cIik7XG4gIH1cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMSh7XG4gICAgYW5jaG9yOiB7XG4gICAgICBvZmZzZXQ6IGFuY2hvci5vZmZzZXQsXG4gICAgICBwYXRoOiBhbmNob3IucGF0aFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIG9mZnNldDogZm9jdXMub2Zmc2V0LFxuICAgICAgcGF0aDogZm9jdXMucGF0aFxuICAgIH1cbiAgfSwgYXR0cmlidXRlcyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGBUZXh0YCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHQodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5vZGVzID0gcmVzb2x2ZURlc2NlbmRhbnRzKGNoaWxkcmVuKTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IG9ubHkgY29udGFpbiBhIHNpbmdsZSBub2RlJ3Mgd29ydGggb2YgY2hpbGRyZW4uXCIpO1xuICB9XG4gIHZhciBbbm9kZV0gPSBub2RlcztcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIG5vZGUgPSB7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH07XG4gIH1cbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICBUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBjYW4gb25seSBjb250YWluIHRleHQgY29udGVudCBhcyBjaGlsZHJlbi5cIik7XG4gIH1cbiAgLy8gQ09NUEFUOiBJZiB0aGV5IHVzZWQgdGhlIDx0ZXh0PiB0YWcgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCBiZVxuICAvLyBtZXJnZSB3aXRoIG90aGVyIHN0cmluZyBjaGlsZHJlbi5cbiAgU1RSSU5HUy5kZWxldGUobm9kZSk7XG4gIE9iamVjdC5hc3NpZ24obm9kZSwgYXR0cmlidXRlcyk7XG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0b3AtbGV2ZWwgYEVkaXRvcmAgb2JqZWN0LlxuICovXG52YXIgY3JlYXRlRWRpdG9yID0gbWFrZUVkaXRvciA9PiAodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pID0+IHtcbiAgdmFyIG90aGVyQ2hpbGRyZW4gPSBbXTtcbiAgdmFyIHNlbGVjdGlvbkNoaWxkO1xuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGNoaWxkKSkge1xuICAgICAgc2VsZWN0aW9uQ2hpbGQgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgdmFyIGRlc2NlbmRhbnRzID0gcmVzb2x2ZURlc2NlbmRhbnRzKG90aGVyQ2hpbGRyZW4pO1xuICB2YXIgc2VsZWN0aW9uID0ge307XG4gIHZhciBlZGl0b3IgPSBtYWtlRWRpdG9yKCk7XG4gIE9iamVjdC5hc3NpZ24oZWRpdG9yLCBhdHRyaWJ1dGVzKTtcbiAgZWRpdG9yLmNoaWxkcmVuID0gZGVzY2VuZGFudHM7XG4gIC8vIFNlYXJjaCB0aGUgZG9jdW1lbnQncyB0ZXh0cyB0byBzZWUgaWYgYW55IG9mIHRoZW0gaGF2ZSB0b2tlbnMgYXNzb2NpYXRlZFxuICAvLyB0aGF0IG5lZWQgaW5jb3Jwb3JhdGVkIGludG8gdGhlIHNlbGVjdGlvbi5cbiAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgIHZhciBhbmNob3IgPSBnZXRBbmNob3JPZmZzZXQobm9kZSk7XG4gICAgdmFyIGZvY3VzID0gZ2V0Rm9jdXNPZmZzZXQobm9kZSk7XG4gICAgaWYgKGFuY2hvciAhPSBudWxsKSB7XG4gICAgICB2YXIgW29mZnNldF0gPSBhbmNob3I7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChmb2N1cyAhPSBudWxsKSB7XG4gICAgICB2YXIgW19vZmZzZXRdID0gZm9jdXM7XG4gICAgICBzZWxlY3Rpb24uZm9jdXMgPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlbGVjdGlvbi5hbmNob3IgJiYgIXNlbGVjdGlvbi5mb2N1cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNsYXRlIGh5cGVyc2NyaXB0IHJhbmdlcyBtdXN0IGhhdmUgYm90aCBgPGFuY2hvciAvPmAgYW5kIGA8Zm9jdXMgLz5gIGRlZmluZWQgaWYgb25lIGlzIGRlZmluZWQsIGJ1dCB5b3Ugb25seSBkZWZpbmVkIGA8YW5jaG9yIC8+YC4gRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zLCB1c2UgYDxjdXJzb3IgLz5gIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmICghc2VsZWN0aW9uLmFuY2hvciAmJiBzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGZvY3VzIC8+YC4gRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zLCB1c2UgYDxjdXJzb3IgLz5gIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChzZWxlY3Rpb25DaGlsZCAhPSBudWxsKSB7XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHNlbGVjdGlvbkNoaWxkO1xuICB9IGVsc2UgaWYgKFJhbmdlLmlzUmFuZ2Uoc2VsZWN0aW9uKSkge1xuICAgIGVkaXRvci5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIH1cbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjcmVhdG9ycyBmb3IgU2xhdGUgb2JqZWN0cy5cbiAqL1xudmFyIERFRkFVTFRfQ1JFQVRPUlMgPSB7XG4gIGFuY2hvcjogY3JlYXRlQW5jaG9yLFxuICBjdXJzb3I6IGNyZWF0ZUN1cnNvcixcbiAgZWRpdG9yOiBjcmVhdGVFZGl0b3IoY3JlYXRlRWRpdG9yJDEpLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBmb2N1czogY3JlYXRlRm9jdXMsXG4gIGZyYWdtZW50OiBjcmVhdGVGcmFnbWVudCxcbiAgc2VsZWN0aW9uOiBjcmVhdGVTZWxlY3Rpb24sXG4gIHRleHQ6IGNyZWF0ZVRleHRcbn07XG4vKipcbiAqIENyZWF0ZSBhIFNsYXRlIGh5cGVyc2NyaXB0IGZ1bmN0aW9uIHdpdGggYG9wdGlvbnNgLlxuICovXG52YXIgY3JlYXRlSHlwZXJzY3JpcHQgPSBmdW5jdGlvbiBjcmVhdGVIeXBlcnNjcmlwdCgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIge1xuICAgIGVsZW1lbnRzID0ge31cbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBlbGVtZW50Q3JlYXRvcnMgPSBub3JtYWxpemVFbGVtZW50cyhlbGVtZW50cyk7XG4gIHZhciBjcmVhdG9ycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX0NSRUFUT1JTKSwgZWxlbWVudENyZWF0b3JzKSwgb3B0aW9ucy5jcmVhdG9ycyk7XG4gIHZhciBqc3ggPSBjcmVhdGVGYWN0b3J5KGNyZWF0b3JzKTtcbiAgcmV0dXJuIGpzeDtcbn07XG4vKipcbiAqIENyZWF0ZSBhIFNsYXRlIGh5cGVyc2NyaXB0IGZ1bmN0aW9uIHdpdGggYG9wdGlvbnNgLlxuICovXG52YXIgY3JlYXRlRmFjdG9yeSA9IGNyZWF0b3JzID0+IHtcbiAgdmFyIGpzeCA9IGZ1bmN0aW9uIGpzeCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGNoaWxkcmVuW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGNyZWF0b3IgPSBjcmVhdG9yc1t0YWdOYW1lXTtcbiAgICBpZiAoIWNyZWF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGh5cGVyc2NyaXB0IGNyZWF0b3IgZm91bmQgZm9yIHRhZzogPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj5cIikpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgY2hpbGRyZW4gPSBbYXR0cmlidXRlc10uY29uY2F0KGNoaWxkcmVuKTtcbiAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gQm9vbGVhbihjaGlsZCkpLmZsYXQoKTtcbiAgICB2YXIgcmV0ID0gY3JlYXRvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgcmV0dXJuIGpzeDtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZSBhIGRpY3Rpb25hcnkgb2YgZWxlbWVudCBzaG9ydGhhbmRzIGludG8gY3JlYXRvciBmdW5jdGlvbnMuXG4gKi9cbnZhciBub3JtYWxpemVFbGVtZW50cyA9IGVsZW1lbnRzID0+IHtcbiAgdmFyIGNyZWF0b3JzID0ge307XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBwcm9wcyA9IGVsZW1lbnRzW3RhZ05hbWVdO1xuICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgYSBoeXBlcnNjcmlwdCBzaG9ydGhhbmQgc2hvdWxkIGJlIGFuIG9iamVjdCwgYnV0IGZvciB0aGUgY3VzdG9tIGVsZW1lbnQgPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj4gIHRhZyB5b3UgcGFzc2VkOiBcIikuY29uY2F0KHByb3BzKSk7XG4gICAgfVxuICAgIGNyZWF0b3JzW3RhZ05hbWVdID0gKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZWxlbWVudCcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH07XG4gIGZvciAodmFyIHRhZ05hbWUgaW4gZWxlbWVudHMpIHtcbiAgICBfbG9vcCgpO1xuICB9XG4gIHJldHVybiBjcmVhdG9ycztcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgaHlwZXJzY3JpcHQgZmFjdG9yeSB0aGF0IHNoaXBzIHdpdGggU2xhdGUsIHdpdGhvdXQgY3VzdG9tIHRhZ3MuXG4gKi9cbnZhciBqc3ggPSBjcmVhdGVIeXBlcnNjcmlwdCgpO1xuXG5leHBvcnQgeyBjcmVhdGVFZGl0b3IsIGNyZWF0ZUh5cGVyc2NyaXB0LCBjcmVhdGVUZXh0LCBqc3ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-hyperscript/dist/index.es.js\n");

/***/ })

};
;